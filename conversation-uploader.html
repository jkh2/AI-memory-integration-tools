<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Conversation Import Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        input, textarea, button {
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        input[type="text"], textarea {
            width: 100%;
            box-sizing: border-box;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        #preview, #memoryPreview {
            border: 1px solid #ddd;
            padding: 10px;
            max-height: 400px;
            overflow-y: auto;
            background-color: #f9f9f9;
        }
        .message, .memory {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 4px;
        }
        .message.system, .memory {
            background-color: #f0f0f0;
        }
        .error {
            color: red;
            font-weight: bold;
        }
        .warning {
            color: orange;
            font-weight: bold;
        }
        .section {
            border-top: 2px solid #ccc;
            padding-top: 15px;
        }
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            input, textarea, button {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Chat Conversation Import Tool</h1>
        <!-- Upload Section -->
        <h2>Upload Conversations</h2>
        <input type="text" id="apiKey" placeholder="Remember API Key">
        <input type="text" id="userId" placeholder="User ID (e.g., email or database ID)">
        <input type="text" id="baseTimestamp" placeholder="Optional: Base Timestamp (YYYY-MM-DDTHH:MM:SSZ)">
        <input type="text" id="sessionId" placeholder="Optional: Session ID or Title">
        <input type="text" id="sidlf" placeholder="Optional: SIDLF (e.g., Orion Sentinel)" value="Orion Sentinel">
        <label><input type="checkbox" id="stripPii"> Strip PII</label>
        <label><input type="checkbox" id="filterResults"> Filter Results with LLM</label>
        <label><input type="checkbox" id="includeMemoryId"> Include Memory ID</label>
        <input type="file" id="jsonFile" accept=".json">
        <textarea id="jsonInput" placeholder="Paste conversations.json content here" rows="5" style="display: none;"></textarea>
        <button onclick="toggleJsonInput()" id="jsonToggle">Paste JSON Instead</button>
        <button onclick="parseConversation()">Parse Conversation</button>
        <div id="preview"></div>
        <div>
            <button onclick="downloadJson()">Download as JSON</button>
            <button onclick="copyToClipboard()">Copy to Clipboard</button>
            <button onclick="postToApi()" id="apiButton" disabled>POST to Remember API</button>
        </div>
        <div id="status" class="error"></div>

        <!-- Retrieval Section -->
        <div class="section">
            <h2>Retrieve Memories</h2>
            <input type="text" id="retrieveUserId" placeholder="User ID for retrieval">
            <input type="text" id="retrieveSidlf" placeholder="Optional: SIDLF filter (e.g., Orion Sentinel)">
            <input type="text" id="retrieveSessionId" placeholder="Optional: Session ID filter">
            <button onclick="retrieveMemories()">Retrieve Memories</button>
            <div id="memoryPreview"></div>
            <div id="retrieveStatus" class="error"></div>
        </div>

        <!-- Prompt Stitcher Section -->
        <div class="section">
            <h2>Generate Prompt with Memories</h2>
            <textarea id="queryInput" placeholder="Enter your query" rows="3"></textarea>
            <button onclick="generatePrompt()">Generate Prompt</button>
            <textarea id="promptOutput" placeholder="Generated prompt will appear here" rows="5" readonly></textarea>
            <div id="promptStatus" class="error"></div>
        </div>
    </div>

    <script>
        // Main conversation array
        let conversation = [];
        let sourceUrl = 'openai_export';
        let sessionId = '';
        let retrievedMemories = [];

        // Initialize IndexedDB
        let db;
        const dbRequest = indexedDB.open('ConversationDB', 1);
        dbRequest.onupgradeneeded = (event) => {
            db = event.target.result;
            db.createObjectStore('conversations', { keyPath: 'sessionId' });
        };
        dbRequest.onsuccess = (event) => {
            db = event.target.result;
        };

        // Toggle between JSON file and JSON paste input
        function toggleJsonInput() {
            const jsonInput = document.getElementById('jsonInput');
            const jsonFile = document.getElementById('jsonFile');
            const jsonToggle = document.getElementById('jsonToggle');
            if (jsonInput.style.display === 'none') {
                jsonInput.style.display = 'block';
                jsonFile.style.display = 'none';
                jsonToggle.textContent = 'Upload JSON File Instead';
            } else {
                jsonInput.style.display = 'none';
                jsonFile.style.display = 'block';
                jsonToggle.textContent = 'Paste JSON Instead';
            }
        }

        // JSON Schema for validation
        const schema = {
            type: 'array',
            items: {
                type: 'object',
                required: ['role', 'content', 'chunk_id'],
                properties: {
                    role: { type: 'string', enum: ['system'] },
                    content: { type: 'string' },
                    timestamp: { type: 'string', pattern: '^[0-9]{4}-[0-9]{2}-[0-9]{2}T.*Z$' },
                    source_url: { type: 'string' },
                    session_id: { type: 'string' },
                    sidlf: { type: 'string' },
                    chunk_id: { type: 'string' }
                }
            }
        };

        // Simple schema validator
        function validateConversation(conv) {
            if (!Array.isArray(conv)) return false;
            return conv.every(msg => {
                if (!msg.role || msg.role !== 'system') return false;
                if (!msg.content || typeof msg.content !== 'string') return false;
                if (!msg.chunk_id || typeof msg.chunk_id !== 'string') return false;
                if (msg.timestamp && !/^[0-9]{4}-[0-9]{2}-[0-9]{2}T.*Z$/.test(msg.timestamp)) return false;
                return true;
            });
        }

        // Parse conversation from JSON file or pasted JSON
        async function parseConversation() {
            const jsonInput = document.getElementById('jsonInput').value;
            const jsonFile = document.getElementById('jsonFile').files[0];
            const baseTimestamp = document.getElementById('baseTimestamp').value;
            const sidlf = document.getElementById('sidlf').value;
            sessionId = document.getElementById('sessionId').value || `session_${Date.now()}`;
            const status = document.getElementById('status');
            conversation = [];

            status.textContent = '';
            document.getElementById('apiButton').disabled = !document.getElementById('apiKey').value || !document.getElementById('userId').value;

            // Check for duplicates in IndexedDB
            const transaction = db.transaction(['conversations'], 'readonly');
            const store = transaction.objectStore('conversations');
            const request = store.get(sessionId);
            request.onsuccess = () => {
                if (request.result) {
                    status.textContent = `Warning: Session ID '${sessionId}' already exists in local storage.`;
                    status.className = 'warning';
                }
            };

            try {
                let jsonContent = '';

                if (jsonInput) {
                    jsonContent = jsonInput;
                } else if (jsonFile) {
                    jsonContent = await jsonFile.text();
                } else {
                    status.textContent = 'Please provide a JSON file or paste JSON content.';
                    return;
                }

                // Parse and transform OpenAI JSON
                const openAiData = JSON.parse(jsonContent);
                conversation = chunkAndTransformOpenAiJson(openAiData, baseTimestamp, sidlf);
                if (!validateConversation(conversation)) {
                    status.textContent = 'Invalid conversation format. Ensure all messages have role, content, and chunk_id.';
                    return;
                }
                saveToIndexedDB();
                renderPreview();
            } catch (e) {
                status.textContent = 'Error parsing JSON: ' + e.message;
            }
        }

        // Chunk and transform OpenAI conversations.json
        function chunkAndTransformOpenAiJson(data, baseTimestamp, sidlf) {
            const messages = [];
            let currentTime = baseTimestamp ? new Date(baseTimestamp) : new Date();
            let messageIndex = 0;
            let chunkIdCounter = 0;

            // Estimate tokens (1 token ~ 4 characters)
            function estimateTokens(text) {
                return Math.ceil(text.length / 4);
            }

            // Process each conversation
            data.forEach(convo => {
                const convoMessages = convo.messages || [];
                let currentChunk = [];
                let currentTokenCount = 0;
                const minTokens = 500;
                const maxTokens = 1000;

                convoMessages.forEach(msg => {
                    if (msg.role && msg.content) {
                        const tokenCount = estimateTokens(msg.content);
                        if (currentTokenCount + tokenCount > maxTokens && currentChunk.length > 0) {
                            // Save current chunk
                            messages.push({
                                role: 'system',
                                content: currentChunk.map(m => `${m.role}: ${m.content}`).join('\n'),
                                source_url: sourceUrl,
                                session_id: sessionId,
                                chunk_id: `chunk_${chunkIdCounter++}`,
                                ...(sidlf && { sidlf }),
                                ...(currentChunk[0].create_time || baseTimestamp ? {
                                    timestamp: currentChunk[0].create_time || new Date(currentTime.getTime() + messageIndex * 60000).toISOString()
                                } : {})
                            });
                            currentChunk = [];
                            currentTokenCount = 0;
                        }
                        currentChunk.push(msg);
                        currentTokenCount += tokenCount;
                        messageIndex++;

                        // Ensure small chunks are saved
                        if (currentTokenCount >= minTokens || !msg.content) {
                            messages.push({
                                role: 'system',
                                content: currentChunk.map(m => `${m.role}: ${m.content}`).join('\n'),
                                source_url: sourceUrl,
                                session_id: sessionId,
                                chunk_id: `chunk_${chunkIdCounter++}`,
                                ...(sidlf && { sidlf }),
                                ...(msg.create_time || baseTimestamp ? {
                                    timestamp: msg.create_time || new Date(currentTime.getTime() + messageIndex * 60000).toISOString()
                                } : {})
                            });
                            currentChunk = [];
                            currentTokenCount = 0;
                        }
                    }
                });

                // Save any remaining chunk
                if (currentChunk.length > 0) {
                    messages.push({
                        role: 'system',
                        content: currentChunk.map(m => `${m.role}: ${m.content}`).join('\n'),
                        source_url: sourceUrl,
                        session_id: sessionId,
                        chunk_id: `chunk_${chunkIdCounter++}`,
                        ...(sidlf && { sidlf }),
                        ...(currentChunk[0].create_time || baseTimestamp ? {
                                    timestamp: currentChunk[0].create_time || new Date(currentTime.getTime() + messageIndex * 60000).toISOString()
                                } : {})
                    });
                }
            });

            return messages;
        }

        // Save to IndexedDB
        function saveToIndexedDB() {
            const transaction = db.transaction(['conversations'], 'readwrite');
            const store = transaction.objectStore('conversations');
            store.put({ sessionId, conversation });
        }

        // Render preview of parsed messages
        function renderPreview() {
            const preview = document.getElementById('preview');
            preview.innerHTML = '';
            conversation.forEach(msg => {
                const div = document.createElement('div');
                div.className = `message ${msg.role}`;
                div.innerHTML = `<strong>${msg.role.toUpperCase()}</strong> (Chunk ${msg.chunk_id}, ${msg.timestamp || 'No timestamp'}): ${msg.content.substring(0, 100)}... <br>` +
                                `Source: ${msg.source_url || 'N/A'}, Session: ${msg.session_id}, SIDLF: ${msg.sidlf || 'N/A'}`;
                preview.appendChild(div);
            });
        }

        // Retrieve memories from Remember API
        async function retrieveMemories() {
            const apiKey = document.getElementById('apiKey').value;
            const userId = document.getElementById('retrieveUserId').value;
            const sidlf = document.getElementById('retrieveSidlf').value;
            const sessionId = document.getElementById('retrieveSessionId').value;
            const status = document.getElementById('retrieveStatus');
            const memoryPreview = document.getElementById('memoryPreview');

            status.textContent = '';
            retrievedMemories = [];

            if (!apiKey || !userId) {
                status.textContent = 'Missing API key or user ID.';
                return;
            }

            try {
                const response = await fetch('https://api.x.ai/v1/memories/get', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        apikey: apiKey,
                        userid: userId,
                        ...(sidlf && { additionalcontext: `sidlf:${sidlf}` }),
                        ...(sessionId && { additionalcontext: `session_id:${sessionId}` })
                    })
                });
                if (!response.ok) throw new Error('API request failed');
                const data = await response.json();
                retrievedMemories = data.memories || [];
                renderMemoryPreview();
            } catch (e) {
                status.textContent = `Error retrieving memories: ${e.message}`;
            }
        }

        // Render retrieved memories
        function renderMemoryPreview() {
            const memoryPreview = document.getElementById('memoryPreview');
            memoryPreview.innerHTML = '';
            retrievedMemories.forEach((memory, index) => {
                const div = document.createElement('div');
                div.className = 'memory';
                const content = typeof memory === 'string' ? memory : memory.content;
                const memoryId = typeof memory === 'object' ? memory.memoryId : 'N/A';
                div.innerHTML = `<strong>Memory ${index + 1}</strong> (ID: ${memoryId}): ${content.substring(0, 100)}... <br>` +
                                `<button onclick="deleteMemory('${memoryId}')">Delete</button>`;
                memoryPreview.appendChild(div);
            });
        }

        // Delete a memory
        async function deleteMemory(memoryId) {
            const apiKey = document.getElementById('apiKey').value;
            const userId = document.getElementById('retrieveUserId').value;
            const status = document.getElementById('retrieveStatus');

            if (!apiKey || !userId || !memoryId) {
                status.textContent = 'Missing API key, user ID, or memory ID.';
                return;
            }

            try {
                const response = await fetch('https://api.x.ai/v1/memories/delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        apikey: apiKey,
                        userid: userId,
                        memoryId: memoryId
                    })
                });
                if (!response.ok) throw new Error('API request failed');
                status.textContent = `Memory ${memoryId} deleted successfully!`;
                retrieveMemories(); // Refresh memory list
            } catch (e) {
                status.textContent = `Error deleting memory: ${e.message}`;
            }
        }

        // Generate prompt with stitched memories
        function generatePrompt() {
            const query = document.getElementById('queryInput').value;
            const promptOutput = document.getElementById('promptOutput');
            const status = document.getElementById('promptStatus');
            const k = 3; // Top-k memories

            if (!query) {
                status.textContent = 'Please enter a query.';
                return;
            }

            if (!retrievedMemories.length) {
                status.textContent = 'No memories retrieved. Please retrieve memories first.';
                return;
            }

            // Simple client-side stitching (limited to retrieved memories)
            const topMemories = retrievedMemories.slice(0, k);
            const memoryContext = topMemories.map((memory, index) => {
                const content = typeof memory === 'string' ? memory : memory.content;
                return `Memory ${index + 1}: ${content}`;
            }).join('\n\n');
            const prompt = `${memoryContext}\n\nCurrent Query: ${query}`;

            promptOutput.value = prompt;
            status.textContent = 'Prompt generated successfully!';
        }

        // Download as JSON
        function downloadJson() {
            if (!conversation.length) {
                document.getElementById('status').textContent = 'No conversation to download.';
                return;
            }
            const blob = new Blob([JSON.stringify(conversation, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'conversation.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Copy to clipboard
        function copyToClipboard() {
            if (!conversation.length) {
                document.getElementById('status').textContent = 'No conversation to copy.';
                return;
            }
            navigator.clipboard.writeText(JSON.stringify(conversation, null, 2))
                .then(() => document.getElementById('status').textContent = 'Copied to clipboard!')
                .catch(() => document.getElementById('status').textContent = 'Failed to copy.');
        }

        // POST to Remember API
        async function postToApi() {
            const apiKey = document.getElementById('apiKey').value;
            const userId = document.getElementById('userId').value;
            const stripPii = document.getElementById('stripPii').checked;
            const filterResults = document.getElementById('filterResults').checked;
            const includeMemoryId = document.getElementById('includeMemoryId').checked;
            if (!conversation.length || !apiKey || !userId) {
                document.getElementById('status').textContent = 'Missing conversation, API key, or user ID.';
                return;
            }
            if (!validateConversation(conversation)) {
                document.getElementById('status').textContent = 'Invalid conversation format for API.';
                return;
            }

            // Chunk API POSTs to handle large datasets
            const chunkSize = 50;
            for (let i = 0; i < conversation.length; i += chunkSize) {
                const chunk = conversation.slice(i, i + chunkSize);
                try {
                    const response = await fetch('https://api.x.ai/v1/remember', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            apikey: apiKey,
                            userid: userId,
                            messagecontent: JSON.stringify(chunk),
                            strippii: stripPii,
                            filterresults: filterResults,
                            includememoryid: includeMemoryId
                        })
                    });
                    if (!response.ok) throw new Error('API request failed');
                    document.getElementById('status').textContent = `Successfully posted chunk ${i / chunkSize + 1} to Remember API!`;
                } catch (e) {
                    document.getElementById('status').textContent = `API Error for chunk ${i / chunkSize + 1}: ${e.message}`;
                    return;
                }
            }
        }
    </script>
<br><br><center><a href="index.html"><img src="home.png"</a></center>
</body>
</html>
